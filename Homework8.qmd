---
title: "ST558 Homework8"
format: html
editor: visual
---

# Jamin Goo (NCSU id : jgoo)

```{r}
#| message: FALSE
#| warning: FALSE

# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(lubridate)
library(janitor)
```

## 1. Reading Data

```{r}
bike_data_raw <- read_csv("SeoulBikeData.csv", 
                          locale = locale(encoding = "latin1"))
```

## 2. EDA

### Checking the Data

```{r}
# 1. Check for missingness
print(colSums(is.na(bike_data_raw)))
```

All columns are 0 : There is no missing.

```{r}
# 2. Check column types and values
glimpse(bike_data_raw)
summary(bike_data_raw |> select(where(is.numeric)))
print(map(bike_data_raw |> select(where(is.character), -Date), unique))
```

```{r}
# 3, 4, 5. Convert Date, Convert to Factors, Rename
bike_data_cleaned <- bike_data_raw |>
  mutate(
    Date = dmy(Date), # 3. Convert the Date column into an actual date 
    Seasons = factor(Seasons), # 4: Turn the character variables 
    Holiday = factor(Holiday), # 4: Turn the character variables 
  ) |>
  clean_names() |> # 5: Rename all the variables to have easy to use names 
  mutate(
    functioning_day = factor(functioning_day) # 4: Turn the character variables 
  )

glimpse(bike_data_cleaned)
```

2.  

```{r}
# 6: Create summary statistics (especially related to the bike rental count)
print(
  bike_data_cleaned |>
    group_by(functioning_day) |>
    summarize(
      count = n(),
      min_bikes = min(rented_bike_count),
      mean_bikes = mean(rented_bike_count),
      max_bikes = max(rented_bike_count)
    )
)

# 6: Subset the data appropriately
bike_data_functional <- bike_data_cleaned |>
  filter(functioning_day == "Yes")

summary(bike_data_functional)

bike_data_functional_no <- bike_data_cleaned |>
  filter(functioning_day == "No")

summary(bike_data_functional_no)
```

If the bike is not functioning, the rented bike count is always 0.

So we will focus on the data where the bike is functioning for further analysis.

```{r}
# 7: To simplify our analysis, we’ll summarize across the hours
bike_data_daily <- bike_data_functional |>
  group_by(date, seasons, holiday) |>
  summarize(
    # Find the sum of rented_bike_count, rainfall, and snowfall
    rented_bike_count_sum = sum(rented_bike_count),
    rainfall_sum_mm = sum(rainfall_mm),
    snowfall_sum_cm = sum(snowfall_cm),
    
    # Find the mean of all the weather related variables
    temperature_mean_c = mean(temperature_c),
    humidity_mean_percent = mean(humidity_percent),
    wind_speed_mean_m_s = mean(wind_speed_m_s),
    visibility_mean_10m = mean(visibility_10m),
    dew_point_temperature_mean_c = mean(dew_point_temperature_c),
    solar_radiation_mean_mj_m2 = mean(solar_radiation_mj_m2),
    
    .groups = 'drop' 
  )

glimpse(bike_data_daily)
```

```{r}
# 8: Recreate my basic summary stats
summary(bike_data_daily)

# Plot: Rented Bike Count vs. Mean Temperature
plot_temp <- bike_data_daily |>
  ggplot(aes(x = temperature_mean_c , y = rented_bike_count_sum)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(
    title = "Daily Bike Rentals vs. Mean Temperature",
    x = "Mean Temperature (C)",
    y = "Sum of Daily Bike Rentals"
  )
print(plot_temp)

#  correlation between my numeric variables
cor_matrix <- bike_data_daily |>
  select(where(is.numeric)) |>
  cor()
print(round(cor_matrix, 2))
```

## 3. Split the Data

```{r}
set.seed(10)
bike_split <- initial_split(bike_data_daily, prop = 0.75, strata = seasons)
bike_train <- training(bike_split)
bike_test <- testing(bike_split)
bike_CV_folds <- vfold_cv(bike_train, v = 10, strata = seasons)
```

## 4. Fitting MLR Models

Create some recipes.
```{r}
MLR_recipe1 <- recipe(rented_bike_count_sum ~ ., data = bike_train) |>
  # Ignore the date variable for modeling
  step_date(date, features = c("dow")) |>
  step_mutate(day_type = factor(if_else(date_dow %in% c("Sat", "Sun"), 
                                        "weekend", "weekday"))) |>
  step_rm(date, date_dow) |> 
  # Standardize the numeric variables since their scales are pretty different.
  step_normalize(all_numeric_predictors()) |>
  # Create dummy variables for the seasons, holiday, and our new day type variable
  step_dummy(all_nominal_predictors())

# recipe 2: 1.Do the same steps as above.
MLR_recipe2 <- MLR_recipe1 |>
  # Addin interactions between seasons and holiday, seasons and temp, temp and rainfall.
  step_interact(~ starts_with("seasons_"):starts_with("holiday_")) |>
  step_interact(~ starts_with("seasons_"):temperature_mean_c) |>
  step_interact(~ temperature_mean_c:rainfall_sum_mm)

# recipe 3: 1.Do the same steps as the 2nd recipe.
MLR_recipe3 <- MLR_recipe2 |>
  # Add in quadratic terms for each numeric predictor
  step_poly(
    rainfall_sum_mm, snowfall_sum_cm, temperature_mean_c, humidity_mean_percent,
    wind_speed_mean_m_s, visibility_mean_10m, dew_point_temperature_mean_c,
    solar_radiation_mean_mj_m2,
    degree = 2
  )
```

Set up our linear model fit to use the “lm” engine.
```{r}
MLR_spec <- linear_reg() |>
  set_engine("lm") 
```

```{r}
MLR_wkf1 <- workflow() |>
  add_recipe(MLR_recipe1) |>
  add_model(MLR_spec)
MLR_wkf2 <- workflow() |>
  add_recipe(MLR_recipe2) |>
  add_model(MLR_spec)
MLR_wkf3 <- workflow() |>
  add_recipe(MLR_recipe3) |>
  add_model(MLR_spec)
```

Fit the models using 10 fold CV via fit_resamples() 
```{r}
MLR_fit1 <-  MLR_wkf1 |>
  fit_resamples(bike_CV_folds)
MLR_fit2 <- MLR_wkf2 |>
  fit_resamples(bike_CV_folds)
MLR_fit3 <- MLR_wkf3 |>
  fit_resamples(bike_CV_folds)

cv_rmse_summary <- rbind(
    MLR_fit1 |> collect_metrics() |> filter(.metric == "rmse"),
    MLR_fit2 |> collect_metrics() |> filter(.metric == "rmse"),
    MLR_fit3 |> collect_metrics() |> filter(.metric == "rmse")
  ) |> 
  mutate(Model = c("Model 1", "Model 2", "Model 3")) |>
  select(Model, mean, n, std_err)

# Print the final RMSE summary
print(cv_rmse_summary)
```

From CV results, Model 3 had the lowest RMSE (≈ 2987.662). So it is selected as the best model.
```{r}
lowest_rmse <- MLR_wkf3

# Obtain final model on the test set
final_model <- lowest_rmse |>
  last_fit(bike_split)

# Compute the RMSE metric on the test set
test_set_metrics <- final_model |>
  collect_metrics()

print(test_set_metrics)
```
Obtain the final model coefficient table
```{r}

# coefficient table using extract_fit_parsnip() and tidy()
coefficient_table <- final_model |>
  extract_fit_parsnip() |>
  tidy()
  
# Print the coefficient table
print(coefficient_table, n=40)
```